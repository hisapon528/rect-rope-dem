<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>教科書p102 応用例題3（幾何→グラフ表示切替）</title>
<style>
  :root{
    --gap:16px;          /* パネル間の間隔 */
    --bar-h:56px;        /* 上部バーの高さ目安 */
    --ui:14px;
  }
  html,body{height:100%;margin:0}
  body{
    display:grid; grid-template-rows: var(--bar-h) 1fr;
    min-height:100svh; background:#fafafa; color:#333;
    font:var(--ui)/1.5 system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif;
  }

  /* 上部バー（a, x, グラフ表示, 軌跡） */
  header{
    background:#fff; border-bottom:1px solid #e6e6e6; padding:10px 12px;
    display:flex; gap:24px; align-items:center; flex-wrap:wrap;
  }
  .grp{display:flex; align-items:center; gap:8px}
  input[type="number"]{width:92px; padding:6px 8px; border:1px solid #cfcfcf; border-radius:8px; font:inherit}
  input[type="range"]{width:160px}
  button{appearance:none; border:1px solid #cfcfcf; border-radius:8px; background:#fff; padding:6px 10px; cursor:pointer; font:inherit}

  /* メイン2パネル（固定高 + キャンバス100%） */
  main{
    min-height:0; padding:var(--gap); box-sizing:border-box; overflow:hidden;
    display:grid; grid-template-columns: minmax(300px,1fr) minmax(300px,1fr); gap:var(--gap);
    max-width:1200px; margin-inline:auto;
  }
  /* 1カラム時（グラフ非表示） */
  main.onecol{ grid-template-columns: 1fr; }

  .panel{
    background:#fff; border:1px solid #eee; border-radius:12px; box-shadow:0 1px 0 rgba(0,0,0,.03) inset;
    overflow:hidden; height: calc(88svh - var(--bar-h)); min-height:420px;
  }
  canvas{display:block; width:100%; height:100%}

  /* スマホ：縦1カラム＋パネルをさらにコンパクトに */
  @media (max-width: 960px){
    :root{ --bar-h:64px }
    header{gap:12px}
    .grp{flex:1 1 48%}
    main{grid-template-columns: 1fr}
    .panel{height: calc(44svh - var(--bar-h)); min-height:320px}
    input[type="range"]{width:140px}
  }
</style>
</head>
<body>
  <header>
    <div class="grp">
      <label id="labA" for="aIn">𝑎:</label>
      <input id="aIn" type="number" step="0.1" min="0.1" value="8">
    </div>
    <div class="grp">
      <label id="labX" for="xRange">𝑥:</label>
      <input id="xRange" type="range" min="0" max="1000" value="500">
      <input id="xIn" type="number" step="0.1" min="0" value="4">
    </div>

    <!-- 並び順：グラフ表示 → （右側に）軌跡トグル -->
    <button id="graphBtn">グラフ表示</button>
    <button id="traceBtn" style="display:none">軌跡を表示</button>
  </header>

  <!-- 最初は 1 カラム（幾何のみ） -->
  <main id="main" class="onecol">
    <div class="panel" id="geomPanel"><canvas id="geom"></canvas></div>
    <!-- グラフは初期非表示 -->
    <div class="panel" id="graphPanel" style="display:none"><canvas id="graph"></canvas></div>
  </main>

<script>
/* ===== 状態 ===== */
const state = { a:8, x:4, showTrace:false, trace:[] };
const aIn = document.getElementById('aIn');
const xIn = document.getElementById('xIn');
const xRange = document.getElementById('xRange');
const traceBtn = document.getElementById('traceBtn');
const graphBtn = document.getElementById('graphBtn');
const cvsGeom = document.getElementById('geom');
const cvsGraph = document.getElementById('graph');
const graphPanel = document.getElementById('graphPanel');
const mainWrap = document.getElementById('main');
const DPR = Math.max(1, window.devicePixelRatio||1);
const mqCompact = window.matchMedia('(max-width: 960px)');
const isCompact = ()=> mqCompact.matches;

/* ===== 入力（双方向同期） ===== */
function applyA(){
  const a = Math.max(0.1, parseFloat(aIn.value)||8);
  const ratio = state.a>0 ? state.x/state.a : 0;
  state.a = a;
  state.x = Math.max(0, Math.min(a, ratio*a));
  xIn.max = a;
  xIn.value = state.x.toFixed(3);
  xRange.value = Math.round((state.x/state.a)*1000);
  if (state.showTrace) state.trace = [];
  redrawAll();
}
function applyXFromRange(){
  state.x = (parseInt(xRange.value)/1000)*state.a;
  xIn.value = state.x.toFixed(3);
  if (state.showTrace) pushTrace();
  redrawAll();
}
function applyXFromInput(){
  const x = Math.max(0, Math.min(state.a, parseFloat(xIn.value)||0));
  state.x = x;
  xRange.value = Math.round((state.x/state.a)*1000);
  if (state.showTrace) pushTrace();
  redrawAll();
}
aIn.addEventListener('input', applyA);
xRange.addEventListener('input', applyXFromRange);
xIn.addEventListener('input', applyXFromInput);

/* ===== 軌跡トグル（ボタンはグラフ表示時のみ出す） ===== */
traceBtn.addEventListener('click', ()=>{
  state.showTrace = !state.showTrace;
  traceBtn.textContent = state.showTrace ? '軌跡を非表示' : '軌跡を表示';
  if (!state.showTrace) state.trace = []; else { state.trace = []; pushTrace(); }
  redrawAll();
});

/* ===== グラフ表示の切替（復活） ===== */
let graphVisible = false;
graphBtn.addEventListener('click', ()=>{
  graphVisible = !graphVisible;

  // パネル表示切替
  graphPanel.style.display = graphVisible ? '' : 'none';
  mainWrap.classList.toggle('onecol', !graphVisible);

  // ボタン表示と文言
  graphBtn.textContent = graphVisible ? 'グラフを隠す' : 'グラフ表示';
  if (graphVisible) {
    // 軌跡ボタンを表示（デフォルトはOFF）
    traceBtn.style.display = '';
    state.showTrace = false;
    state.trace = [];
    traceBtn.textContent = '軌跡を表示';
  } else {
    // グラフ非表示 → 軌跡ボタンも非表示＆軌跡クリア
    traceBtn.style.display = 'none';
    state.showTrace = false;
    state.trace = [];
    traceBtn.textContent = '軌跡を表示';
  }

  // 表示状態が変わったらキャンバスをフィットさせて再描画
  setTimeout(()=> {
    fitCanvas(cvsGeom); if (graphVisible) fitCanvas(cvsGraph);
    redrawAll();
  }, 0);
});

/* ===== 軌跡 ===== */
function pushTrace(){
  const y = state.x*(state.a-state.x);
  const last = state.trace[state.trace.length-1];
  if (!last || Math.hypot(last[0]-state.x,last[1]-y)>1e-6){
    state.trace.push([state.x,y]);
    if (state.trace.length>20000) state.trace.shift();
  }
}

/* ===== 自動リサイズ（ResizeObserver + DPR） ===== */
function fitCanvas(cvs){
  const r = cvs.getBoundingClientRect();
  const w = Math.max(1, Math.round(r.width * DPR));
  const h = Math.max(1, Math.round(r.height * DPR));
  if (cvs.width!==w || cvs.height!==h){ cvs.width = w; cvs.height = h; }
  const ctx = cvs.getContext('2d');
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  return {ctx, cssW:r.width, cssH:r.height};
}
function attachAutoResize(cvs, draw){
  const ro = new ResizeObserver(()=> { const {ctx,cssW,cssH}=fitCanvas(cvs); draw(ctx, cssW, cssH); });
  ro.observe(cvs.parentElement);
  // 初回
  const {ctx,cssW,cssH}=fitCanvas(cvs); draw(ctx, cssW, cssH);
}
function redrawAll(){
  const g1 = fitCanvas(cvsGeom); drawGeom(g1.ctx, g1.cssW, g1.cssH);
  if (graphVisible) {
    const g2 = fitCanvas(cvsGraph); drawGraph(g2.ctx, g2.cssW, g2.cssH);
  }
}

/* ===== ロープのタイル（薄茶 + 黒ストライプ / 角なめらか） ===== */
function makeRopeTile(thickness){
  const h = Math.max(8, Math.round(thickness));
  const w = Math.max(96, Math.round(h*6));
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const g = c.getContext('2d');
  // ベース（薄茶）
  g.fillStyle='#d8c090'; g.fillRect(0,0,w,h);
  // 円筒陰影
  const grd = g.createLinearGradient(0,0,0,h);
  grd.addColorStop(0,'rgba(0,0,0,0.18)');
  grd.addColorStop(0.5,'rgba(0,0,0,0.00)');
  grd.addColorStop(1,'rgba(0,0,0,0.22)');
  g.fillStyle=grd; g.fillRect(0,0,w,h);

  // 縞（/// と \\\ を重ねて密度UP）— 黒
  const targetPeriod = Math.max(6, Math.round(h*0.40));
  let N = Math.max(20, Math.floor(w/targetPeriod)); if (N%2===1) N++;
  const period = Math.max(4, Math.floor(w/N));
  const stripeW = Math.max(2, Math.floor(period/2));

  g.save(); g.translate(w/2,h/2); g.rotate(-Math.PI/4); g.translate(-w/2,-h/2);
  g.globalAlpha = 0.80; g.fillStyle='#000';
  for(let i=-N;i<2*N;i++){ g.fillRect(i*period, -w, stripeW, 2*w); }
  g.globalAlpha = 0.60;
  for(let i=-N;i<2*N;i++){ g.fillRect(i*period+stripeW, -w, stripeW, 2*w); }
  g.restore();

  g.save(); g.translate(w/2,h/2); g.rotate(+Math.PI/4); g.translate(-w/2,-h/2);
  g.globalAlpha = 0.28; g.fillStyle='#000';
  for(let i=-N;i<2*N;i++){ g.fillRect(i*period, -w, stripeW, 2*w); }
  g.globalAlpha = 0.20;
  for(let i=-N;i<2*N;i++){ g.fillRect(i*period+stripeW, -w, stripeW, 2*w); }
  g.restore();

  // 微小ノイズ
  const img = g.getImageData(0,0,w,h);
  const dt = img.data;
  for(let i=0;i<dt.length;i+=4){
    const n=(Math.random()-0.5)*12; dt[i]+=n; dt[i+1]+=n; dt[i+2]+=n;
  }
  g.putImageData(img,0,0);
  return {image:c, w, h};
}
function drawRopeEdge(ctx,tile,x1,y1,x2,y2,phase){
  const dx=x2-x1, dy=y2-y1, len=Math.hypot(dx,dy);
  if (len<0.5) return phase;
  const ang=Math.atan2(dy,dx);
  ctx.save();
  ctx.translate(x1,y1); ctx.rotate(ang);
  const pat=ctx.createPattern(tile.image,'repeat');
  if (pat && pat.setTransform){ pat.setTransform(new DOMMatrix().translate(-phase,-tile.h/2)); }
  else{ ctx.translate(-phase,0); }
  ctx.fillStyle=pat; ctx.fillRect(0,-tile.h/2, len, tile.h);
  ctx.restore();
  return (phase+len)%tile.w;
}
function drawRopeArc(ctx,tile,cx,cy,r,a0,a1,phase){
  const L=r*Math.abs(a1-a0);
  const segMax = isCompact()? 4.5 : 6.0;     // 角を滑らかに
  const step=Math.max(4,Math.ceil(L/segMax));
  let px=cx+r*Math.cos(a0), py=cy+r*Math.sin(a0);
  for(let i=1;i<=step;i++){
    const t=i/step, a=a0+(a1-a0)*t;
    const x=cx+r*Math.cos(a), y=cy+r*Math.sin(a);
    phase = drawRopeEdge(ctx,tile,px,py,x,y,phase);
    px=x; py=y;
  }
  return phase;
}
function drawRopeRect(ctx,x,y,w,h,th){
  const tile = makeRopeTile(th);
  let r = Math.min(Math.min(w,h)/2-1, th*(isCompact()?2.6:3.3));
  r = Math.max(0, r);

  ctx.save();
  /* 二重輪郭の間を evenodd で塗りつぶし（継ぎ目ゼロ） */
  ctx.beginPath();
  roundRectPath(ctx, x-th/2, y-th/2, w+th, h+th, r+th/2);
  roundRectPath(ctx, x+th/2, y+th/2, w-th, h-th, Math.max(0,r-th/2));
  ctx.clip('evenodd');

  let phase=0;
  if (r>0.1){
    phase = drawRopeEdge(ctx,tile, x+r,   y,     x+w-r, y,     phase);
    phase = drawRopeArc (ctx,tile, x+w-r, y+r,   r, -Math.PI/2, 0,          phase);
    phase = drawRopeEdge(ctx,tile, x+w,   y+r,   x+w,   y+h-r,  phase);
    phase = drawRopeArc (ctx,tile, x+w-r, y+h-r, r, 0,          Math.PI/2,  phase);
    phase = drawRopeEdge(ctx,tile, x+w-r, y+h,   x+r,   y+h,    phase);
    phase = drawRopeArc (ctx,tile, x+r,   y+h-r, r, Math.PI/2,  Math.PI,    phase);
    phase = drawRopeEdge(ctx,tile, x,     y+h-r, x,     y+r,    phase);
    phase = drawRopeArc (ctx,tile, x+r,   y+r,   r, Math.PI,    3*Math.PI/2,phase);
  }else{
    phase = drawRopeEdge(ctx,tile, x, y, x+w, y, phase);
    phase = drawRopeEdge(ctx,tile, x+w, y, x+w, y+h, phase);
    phase = drawRopeEdge(ctx,tile, x+w, y+h, x, y+h, phase);
    phase = drawRopeEdge(ctx,tile, x, y+h, x, y, phase);
  }
  ctx.restore();

  // 外枠（黒）
  ctx.save();
  ctx.strokeStyle='#000'; ctx.lineWidth=Math.max(1.4, th*0.08);
  ctx.beginPath(); roundRectPath(ctx, x-th/2, y-th/2, w+th, h+th, r+th/2); ctx.stroke();
  ctx.beginPath(); roundRectPath(ctx, x+th/2, y+th/2, w-th, h-th, Math.max(0,r-th/2)); ctx.stroke();
  ctx.restore();
}
function roundRectPath(ctx,x,y,w,h,r){
  r=Math.max(0,Math.min(r,Math.min(w,h)/2));
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,   x+w,y+h, r);
  ctx.arcTo(x+w,y+h, x,  y+h, r);
  ctx.arcTo(x,  y+h, x,  y,   r);
  ctx.arcTo(x,  y,   x+w,y,   r);
  ctx.closePath();
}

/* ===== 幾何パネル ===== */
const GEO_FONT_PX = 28;  // 幾何の文字は大きめ
const GEO_LINE_H  = Math.round(GEO_FONT_PX*1.25);

function drawGeom(ctx, W, H){
  ctx.clearRect(0,0,W,H);
  ctx.font = `${GEO_FONT_PX}px system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif`;

  // 余白（スマホは控えめ）
  const margin = isCompact()? 20 : 24;
  const LEFT_SAFE   = isCompact()? 12 : 12;
  const RIGHT_SAFE  = isCompact()? 160: 180;
  const TOP_SAFE    = isCompact()? GEO_FONT_PX*3 + 18 : GEO_FONT_PX*4 + 28;
  const BOTTOM_SAFE = isCompact()? GEO_FONT_PX*2 + 32 : GEO_FONT_PX*2 + 42;

  // 内箱をさらに少し縮めて見切れ対策
  const SHRINK = isCompact()? 0.86 : 0.88;

  const aw = Math.max(1, W - (margin*2 + LEFT_SAFE + RIGHT_SAFE));
  const ah = Math.max(1, H - (margin*2 + TOP_SAFE + BOTTOM_SAFE));

  const innerW = aw*SHRINK;
  const innerH = ah*SHRINK;
  const padX = (aw - innerW)/2;
  const padY = (ah - innerH)/2;

  const baseLen = Math.min(W,H);
  const thickness = Math.max(10, Math.min(34, Math.round(baseLen * (isCompact()?0.010:0.013))));

  const usableW = Math.max(1, innerW - thickness);
  const usableH = Math.max(1, innerH - thickness);

  const unit = Math.max(0.0001, Math.min(usableW/state.a, usableH/state.a));
  const h = state.x * unit;
  const w = (state.a - state.x) * unit;

  const ox = Math.round(margin + LEFT_SAFE + padX + (innerW - (w + thickness))/2 + thickness/2);
  const oy = Math.round(H - margin - BOTTOM_SAFE - padY - thickness/2);

  drawRopeRect(ctx, ox, oy - h, w, h, thickness);

  // 寸法線・ラベル（＝ をやめて「：」＋単位表記）
  ctx.save();
  ctx.strokeStyle='#666'; ctx.fillStyle='#333'; ctx.lineWidth=1.6;

  const tx = Math.round(ox + w + 22);
  ctx.beginPath(); ctx.moveTo(tx, oy-h); ctx.lineTo(tx, oy);
  ctx.moveTo(tx-8, oy-h); ctx.lineTo(tx+8, oy-h);
  ctx.moveTo(tx-8, oy);   ctx.lineTo(tx+8, oy); ctx.stroke();
  ctx.fillText(`縦の長さ：${state.x.toFixed(3)} m`, tx+10, oy - h/2);

  const ty = Math.round(oy + 26);
  ctx.beginPath(); ctx.moveTo(ox, ty); ctx.lineTo(ox+w, ty);
  ctx.moveTo(ox, ty-8); ctx.lineTo(ox, ty+8);
  ctx.moveTo(ox+w, ty-8); ctx.lineTo(ox+w, ty+8); ctx.stroke();
  const wLabel = `横の長さ：${(state.a-state.x).toFixed(3)} m`;
  ctx.fillText(wLabel, ox + w/2 - ctx.measureText(wLabel).width/2, ty + GEO_FONT_PX*0.9);
  ctx.restore();

  // 情報ボックス（単位 m / m² 付き）
  ctx.save();
  const yVal = state.x*(state.a-state.x);
  const lines = [
    `ロープの長さ：${(2*state.a).toFixed(3)} m`,
    `縦の長さ：${state.x.toFixed(3)} m`,
    `横の長さ：${(state.a-state.x).toFixed(3)} m`,
    `面積：${yVal.toFixed(3)} m²`
  ];
  const pad = 12, bx=margin+LEFT_SAFE-4, by=margin+8;
  const maxw = Math.max(...lines.map(s=>ctx.measureText(s).width));
  const boxW = maxw + pad*2;
  const boxH = GEO_LINE_H*lines.length + pad*2;
  ctx.fillStyle='#fff8d2'; ctx.strokeStyle='#b28a20'; ctx.lineWidth=1.6;
  ctx.beginPath(); roundRectPath(ctx, bx, by, boxW, boxH, 12); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#333';
  lines.forEach((s,i)=> ctx.fillText(s, bx+pad, by+pad + GEO_LINE_H*(i+0.75)));
  ctx.restore();
}

/* ===== グラフパネル ===== */
function niceTicks(min, max, maxCount=7){
  const span = max-min; if (span<=0 || !isFinite(span)) return {start:min, step:1, count:2};
  const stepRaw = span / Math.max(1, maxCount);
  const pow10 = Math.pow(10, Math.floor(Math.log10(stepRaw)));
  const bases = [1,2,2.5,5,10];
  let step=bases[0]*pow10;
  for(const b of bases){ const s=b*pow10; if (span/s<=maxCount){ step=s; break; } }
  const start = Math.ceil(min/step)*step;
  const count = Math.floor((max-start)/step)+1;
  return {start, step, count:Math.max(2,count)};
}
function drawGraph(ctx, W, H){
  ctx.clearRect(0,0,W,H);
  const style = isCompact()
    ? {L:54,R:10,T:18,B:38, grid:6, fs:12}
    : {L:70,R:20,T:30,B:50, grid:10, fs:14};
  ctx.font = `${style.fs}px system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif`;

  const plotW0=Math.max(1, W - style.L - style.R);
  const plotH0=Math.max(1, H - style.T - style.B);
  const SHRINK = isCompact()? 0.90 : 0.92;
  const plotW = plotW0*SHRINK, plotH=plotH0*SHRINK;
  const offX = style.L + (plotW0-plotW)/2;
  const offY = style.T + (plotH0-plotH)/2;

  // 軸の最大値（ご指定：x→a+2, y→a^2/4+2）
  const xMin=0, xMax=Math.max(1e-6, state.a + 2);
  const yMin=0, yMax=Math.max(1e-6, state.a*state.a/4 + 2);

  const X = v=> offX + (v-xMin)/(xMax-xMin)*plotW;
  const Y = v=> offY + (1-(v-yMin)/(yMax-yMin))*plotH;

  // 背景・グリッド
  ctx.fillStyle='#f7f7f7'; ctx.fillRect(offX,offY,plotW,plotH);
  ctx.strokeStyle='#e5e5e5'; ctx.lineWidth=1;

  const tx = niceTicks(xMin, xMax, style.grid);
  const ty = niceTicks(yMin, yMax, style.grid);

  for(let i=0;i<tx.count;i++){
    const xv=tx.start+tx.step*i, sx=X(xv);
    ctx.beginPath(); ctx.moveTo(sx,offY); ctx.lineTo(sx,offY+plotH); ctx.stroke();
    const s=(tx.step<1)?xv.toFixed(1):xv.toFixed(0), w=ctx.measureText(s).width;
    ctx.fillStyle='#555'; ctx.fillText(s, sx-w/2, offY+plotH+16);
  }
  for(let j=0;j<ty.count;j++){
    const yv=ty.start+ty.step*j, sy=Y(yv);
    ctx.beginPath(); ctx.moveTo(offX,sy); ctx.lineTo(offX+plotW,sy); ctx.stroke();
    const s=(ty.step<1)?yv.toFixed(1):yv.toFixed(0), w=ctx.measureText(s).width;
    ctx.fillStyle='#555'; ctx.fillText(s, offX-w-8, sy+4);
  }

  // 軸線
  ctx.strokeStyle='#666'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(offX,offY+plotH); ctx.lineTo(offX+plotW,offY+plotH); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(offX,offY); ctx.lineTo(offX,offY+plotH); ctx.stroke();

  // 軌跡（折れ線）
  if (state.showTrace && state.trace.length>=2){
    ctx.strokeStyle='#1f77b4'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(X(state.trace[0][0]), Y(state.trace[0][1]));
    for(let i=1;i<state.trace.length;i++) ctx.lineTo(X(state.trace[i][0]), Y(state.trace[i][1]));
    ctx.stroke();
  }

  // 現在の点
  const px=state.x, py=state.x*(state.a-state.x);
  ctx.fillStyle='#d62728';
  ctx.beginPath(); ctx.arc(X(px),Y(py),5,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#fff'; ctx.lineWidth=1.2; ctx.stroke();

  const label=`(${px.toFixed(2)}, ${py.toFixed(2)})`;
  const tw = ctx.measureText(label).width;
  const txp = X(px)+10, typ = Y(py)-10;
  ctx.fillStyle='rgba(255,255,255,.92)'; ctx.strokeStyle='#666';
  ctx.beginPath(); roundRectPath(ctx, txp-6, typ-16, tw+12, 22, 8); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#333'; ctx.fillText(label, txp, typ);

  ctx.fillStyle='#333';
  ctx.fillText('面積', offX-32, offY-6);
  ctx.fillText('縦の長さ', offX+plotW+6, offY+plotH+16);
}

/* ===== 初期化 ===== */
(function init(){
  document.getElementById('labA').textContent='𝑎:'; 
  document.getElementById('labX').textContent='𝑥:';
  xIn.max=state.a; aIn.value=state.a; xIn.value=state.x; xRange.value=Math.round((state.x/state.a)*1000);

  // 幾何は常時監視、グラフは最初非表示でも監視を張っておく
  attachAutoResize(cvsGeom, drawGeom);
  attachAutoResize(cvsGraph, drawGraph); // 非表示でもOK。表示切替時にfit+再描画

  // 回転などでも再描画
  window.addEventListener('orientationchange', ()=> setTimeout(redrawAll, 50), {passive:true});
})();
</script>
</body>
</html>
